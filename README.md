# Разработка системы рекомендаций для онлайн-платформ на основе данных о поведении пользователей. (Лабораторная №1)

## Цель работы:
Создать рекомендательную систему (recommender system) с целью максимально точного предсказания предпочтения потребителя и предложить ему наиболее подходящий товар или услугу. Сегодня такие системы встречаются повсеместно. Практически любой крупный интернет-магазин, онлайн-кинотеатр или новостной портал использует ту или иную рекомендательную систему для того, чтобы предоставить пользователям то, что им действительно нужно. В этой работе я создам свою рекомендательную систему для онлайн-кинотеатра.

## Требования.
- Python 3.x
- Google Colab или Jupyter Notebook
  
## Типы рекомендательных систем :
1. **Популярность**:
* Наиболее простая система выдает рекомендации на основе популярности (popularity-based recommender systems). Чем выше средний рейтинг фильма, купленного товара или статьи, тем вероятнее, что система будет рекомендовать именно их.
* Преимуществом является простота, недостатком то, что не учитываются предпочтения конкретного пользователя.

2. **Содержание**:
* Вторым типом рекомендательных систем является, так называемая, фильтрация на основе содержания (content-based filtering).
* В данном случае алгоритм рекомендует товары или услуги, схожие с теми, которые пользователь приобретал ранее.
* Например, если вы посмотрели фильм «Матрица» с Киану Ривзом, то в дальнейшем система будет рекомендовать вам научную фантастику, а также другие фильмы с участием этого актера.
* Такую систему также несложно реализовать, при этом основным недостатком будет то, что покупатели не пробуют новые товары или услуги.
  
3. **Коллаборативная**:
* Третий тип — коллаборативная система (collaborative filtering). Именно её мы и будем создавать.
* Она основывается на сопоставлении пользователей и товаров (или услуг, новостей и т.д.). Математически и графически в данном случае мы работаем с матрицами предпочтений (user-item matrix).
  
**Существует два вида таких систем**
* Коллаборативные системы, основанные на пользователях (user-based), находят близких по предпочтениям пользователей и рекомендуют одному из них то, что уже попробовал другой.
* Системы, основанные на предмете рекомендации (item-based), сравнивают непосредственно близость товаров или услуг. Причем что отличает эту систему, сходство определяется на основе предпочтений всех пользователей, которые оставили свои оценки.
* Мы будем использовать косинусное сходство для оценки расстояния.

## Как работает программа :
1. **Загрузка данных**:
   * Подключаем необходимые библиотеки и датасет о рейтинге фильмов.
   * Датасет включает в себя названия фильмов (файл movies.csv) и оценки, которые фильмам ставили зрители (файл rating.csv).
   * Файлы прикреплены к работе.

2. **Предварительная обработка данных**:
   * Удаляем ненужные столбцы из обоих файлов.
   * Создадим матрицу предпочтений, в которой по горизонтали представлены фильмы, по вертикали - пользователи, а значениями являются оценки.
   * Много ячеек пустуют, пропуски мы замененяем на нули.
   * С помощью фильтров удаляем ненужные оценки и фильмы.

3. **Преобразование данных**:
   * Теперь в нашем датасете очень много нулей. Мы имеем разреженную матрицу (sparse matrix). Одновременно с этим, т.к. столбцов очень много, мы получаем данные с высокой размерностью (high-dimensional data).
   * В таком формате алгоритм будет долго обсчитывать расстояния между фильмами.
   * Чтобы избежать эту проблему, преобразуем данные в формат сжатого хранения строкой (сompressed sparse row, csr).

4. **Обучение модели**:
   * Для обучения модели мы будем использовать алгоритм k-ближайших соседей. Этот алгоритм решает разные задачи, в частности, с его помощью можно заниматься регрессией (класс KNeighborsRegressor) и классификацией (класс KNeighborsClassifier).
   * Для наших целей нам достаточно измерить расстояние между объектами. В этом нам поможет класс машинного обучения NearestNeighbors.
   * ```knn = NearestNeighbors(metric = 'cosine', algorithm = 'brute', n_neighbors = 20, n_jobs = -1)```
   * ```knn.fit(csr_data)```
   * metric = ‘cosine’: выбираем способ измерения расстояния, в нашем случае это будет косинусное сходство
   * algorithm = ‘brute’: предполагает, что мы будем искать решение методом полного перебора (brute force search), в данном случае пространство решений позволяет перебрать все варианты
   * n_neighbors = 20: по скольким соседям ведется обучение
   * n_jobs = -1: в этом случае предполагается, что вычисления будут вестись на всех свободных ядрах процессора

5. **Поиск и рекомендации**:
   * Вводем количество рекомендаций и на основе какого фильма мы их хотим получить (будем смотреть на рекомендации для «Матрицы»).
   * Теперь найдем индекс фильма в матрице предпочтений. Далее с помощью метода ```.kneighbors()``` найдем индексы ближайших соседей «Матрицы».
   * С помощью цикла был создан список, содержащий название фильма и расстояние до него.
  
## Colab
| Colab                                                                                                                                                                          | Info               |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------ |
| [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/drive/1J-uZUAbhl_LOnGnmBKtmUa6sL5UtsxoW?usp=sharing) | Laba1 |

## Результат.
   ![xxxx](https://sun9-1.userapi.com/impg/AilDVz-BS8dfwHLo6R8KhFHahQ5xyzRq2ZCEUA/c0lTbK-Ylt4.jpg?size=442x352&quality=96&sign=763446c626c1450c646b8aa4f8097ce2&type=album).
  * В конечном итоге мы получаем список с наиболее близкими фильмами по предпочтениям зрителей. Чем меньше расстояние, тем, соответственно, исходя из начального выбора, фильм "ближе".
  * Fight Club наиболее рекомендован к просмотру и схож с Matrix, который мы выбрали в качестве "метки" для получения рекомендаций. Дальше идёт Star Wars: Episode V - The Empire Strikes Back и так далее по списку.
  

